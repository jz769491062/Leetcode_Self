/*
1. 是否可以遍历一遍二叉树找到答案？是，则用traverse + 外部变量。例如用queue的层序遍历。
2. 是否可以定义一个递归函数，用子树(子问题)的答案推导最终结果？是，定义递归函数，并充分利用返回值。
例如在后序计算左右子树的最大深度然后取max。

两种模式都需要思考：单独拿出任意一个二叉树节点，他需要做什么，前序后序还是中序？
前序是在本节点完成计算，递归累加；
后序是左右两子树都算完后，递归开始向上累加；
中序是得到一边子树的结果后，处理一下，继续看另一边子树。

也要善用变量来帮助自己保存左右子树的结果。例如：
TreeNode* l = invertTree(root->left);
这样的好处，就是可以直接放心对root->left或right操作了：
root->left = r;
root->right = l;

中序遍历左中右，就是BST的升序排序；中序遍历右中左，就是BST的降序排序。230题

在BST每个节点记录以自己为根的这棵二叉树有多少个节点size，可以知道节点的排名，以此可以根据排名logN获取对应数字
要找排名k, 当前排名/size是m, k < m 则左子树找第k个，k > m 就去右子树找第k - (m + 1)个
看538题、1038题

也可以让递归函数携带额外信息，例如98验证BST就带上了minNode, maxNode

归并排序是后序遍历，快速排序则是前序遍历

*/