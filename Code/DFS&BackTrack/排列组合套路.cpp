===================================================================================================
全排列：
===================================================================================================
无重复数字，元素不可重复使用：
一直从0开始for遍历，使用used数组。
(46.全排列 https://leetcode.cn/problems/permutations/description/)
---------------------------------------------------------------------------------------------------
有重复数字，元素不可重复使用：
一直从0开始for遍历，使用used数组，预先sort数组，判断使用!used[i] && nums[i] == nums[i - 1]
---------------------------------------------------------------------------------------------------
无重复数字，元素可以重复使用：
一直从0开始for遍历
---------------------------------------------------------------------------------------------------
有重复数字，元素可以重复使用：去重数字后同上。
===================================================================================================
全组合：
===================================================================================================
无重复数字，元素不可重复使用：https://leetcode.cn/problems/combinations/description/
从int start开始遍历，递归传入i + 1给start
---------------------------------------------------------------------------------------------------
有重复数字，元素不可重复使用：
从int start开始遍历，递归传入i + 1给start，预先sort数组，判断使用!used[i] && nums[i] == nums[i - 1]
---------------------------------------------------------------------------------------------------
无重复数字，元素可以重复使用：
从int start开始遍历，递归传入i给start
---------------------------------------------------------------------------------------------------
有重复数字，元素可以重复使用：去重数字后同上。
===================================================================================================
总结：
排列Permutation一直从0开始for遍历保证结果一直等于nums长度，所以不需要参数int i
组合Combination从入参start开始for遍历保证各种长度的结果都有，所以需要参数int start
排列Permutation需要used数组保证无重复使用，
组合Combination需要传参i + 1给start保证无重复使用
数字可重复时，用sort和
排列用 i > 0 && nums[i] == nums[i - 1] && !used[i - 1] // 注意used[i - 1]，不是used[i]!
组合用 i > start && candidates[i] == candidates[i - 1]
子集问题直接pushback，然后使用数组相对顺序，currIndex+1，确保子集不重复 https://leetcode.cn/problems/subsets/
组合和子集是一样的：大小为 k 的组合就是大小为 k 的子集。
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]