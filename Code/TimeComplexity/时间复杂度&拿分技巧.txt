// https://mp.weixin.qq.com/s/OQAzopRncZe5cb9_of4mCQ
乘法和加法中的常数因子都可以忽略不计：   
O(2N + 100) = O(N)
O(2^(N+1)) = O(2 * 2^N) = O(2^N)
O(M + 3N + 99) = O(M + N)
但这个常数不能消：
O(2^(2N)) = O(4^N)

凑零钱问题动态规划，遍历树：
递归树是K叉树，K是硬币面值的种数
最差情况是高度为N的一棵满K叉树，所以O(NK)

// 1 + 2 + ... + n = n/2 + (n^2)/2
// 用 Big O 表示化简为 O(n^2)
for (int i = 0; i < n; i++) {
    for (int j = i; j >= 0; j--) {
        dp[i][j] = ...;
    }
}
滑窗双指针，实质上运行时间还是O(N)
单调队列在均摊分析下，push和pop均摊都是O(1)

带备忘录的动态规划运行时间：
  递归的次数 x 函数本身的时间复杂度
= 递归树节点个数 x 每个节点的时间复杂度
= 状态个数 x 计算每个状态的时间复杂度
= 子问题个数 x 解决每个子问题的时间复杂度
= O(N) * O(K)
= O(NK)

如果你把自顶向下带备忘录的解法进一步改写成自底向上的迭代解法：
int coinChange(int[] coins, int amount) {
    // 空间 O(N)
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);

    dp[0] = 0;
    // 时间 O(KN)
    for (int i = 0; i < dp.length; i++) {
        for (int coin : coins) {
            if (i - coin < 0) continue;
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
该解法的时间复杂度不变，但已经不存在递归，所以空间复杂度中不需要考虑堆栈的深度，
只需考虑dp数组的存储空间，虽然用 Big O 表示法来看，该算法的空间复杂度依然是O(N)，
但该算法的实际空间消耗是更小的，所以自底向上迭代的动态规划是各方面性能最好的。

回溯算法：
    全排列：
    每个节点for循环是O(N)，叶子结点copy到res还是O(N)
    而节点总数是P(N, 0) + P(N, 1) + P(N, 2) + ... + P(N, N)
    这一堆排列数累加不好算，粗略估计一下上界吧，把它们全都扩大成P(N, N) = N!，那么节点总数的上界就是O(N*N!)。
    现在就可以得出算法的总时间复杂度：
    递归的次数 x 函数本身的时间复杂度
    = 递归树节点个数 x 每个节点的时间复杂度
    = O(N*N!) * O(N)
    = O(N^2 * N!)

    子集：
    backtrack执行一次是O(N)，节点数是组合数求和C(N, 0) + C(N, 1) + C(N, 2) + ... + C(N, N) = 2^N。
    递归的次数 x 函数本身的时间复杂度
        = 递归树节点个数 x 每个节点的时间复杂度
        = O(2^N) * O(N)
        = O(N*2^N)
    
====================================================================================
骗分套路：
如果输出就是简单的yes,no; 0, 1之类的话，可以用随机数过一部分题目。

    Java 的 IntelliJ比较香，有psvm 和 sout 这样的快捷命令（你要是连这都不知道，赶紧面壁去），而且可以帮你检查出很多笔误，
    比如说 while 循环里面忘记递增变量，或者 return 语句错写到循环里这种由于疏忽所导致的问题。

Python奇技淫巧多，表达式求值算法 是一个困难级别的算法，但如果用 Python 内置的 exec 函数，直接就能算出答案。

代码分成几个函数，让调试更容易。

我的建议是直接在递归函数内部打印关键值，配合缩进，直观地观察递归函数执行情况。
最能提升我们 debug 效率的是缩进，除了解法函数，我们新定义一个函数 printIndent 和一个全局变量 count：
// 全局变量，记录递归函数的递归层数
int count = 0;
// 输入 n，打印 n 个 tab 缩进
void printIndent(int n) {
    for (int i = 0; i < n; i++) {
        printf("   ");
    }
}
接下来，套路来了：
在递归函数的开头，调用 printIndent(count++) 并打印关键变量；然后在所有 return 语句之前调用 printIndent(--count) 并打印返回值。
这样打印出来直接就是一个递归树的效果，非常直观看出代码哪里有问题。
================================================================
考前复习策略：
考前就别和某一道算法题死磕了，不划算。
应该尽可能多的看各种各样的题目，思考五分钟，想不出来解法的话直接看别人的答案。看懂思路就行了，甚至自己写一遍都没必要，因为比较浪费时间。
笔试的时候最怕的是没思路，所以把各种题型都过目一下，起码心里不会慌，只要有思路，平均一道题二三十分钟搞定还是不难的。
前面不是说了么，没有什么问题是暴力穷举解决不了的，直接用 回溯算法套路框架 硬上，大不了加个备忘录，不就成 动态规划套路框架 了么，再大不了这题我不做了么，暴力过上 60% 的 case 也挺 OK 的。
别的不多说了，套路这个东西，说来简单，一点就透，但问题是不点就不透。
